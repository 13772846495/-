5.18：最大子序和

题目要求：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

代码：int maxSubArray(int* nums, int numsSize){
    int i, sum = 0, max = nums[0]; 
    for(i = 0; i < numsSize; i++)
    {
        if(sum > 0)
        {
            sum += nums[i];
        }
        else
        {
            sum = nums[i];
        }
        if(sum > max)
        {
            max = sum;
        }
    }
    return max;
}

总结：在练习使用动态规划的时候要着重考虑所需和所给内容之间的联系，思考如何
利用变化的数组求解。

5.23：打家劫舍

题目要求：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
示例 1:
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2:
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

代码：int max(int a, int b)
{
    return a > b ? a : b;
}

int rob(int* nums, int numsSize){
    if(numsSize == 0)
        return 0;
    if(numsSize == 1)
        return nums[0];
    int sum[numsSize], i;
    sum[0] = nums[0];
    sum[1] = max(nums[1], nums[0]);
    for(i = 2; i < numsSize; i++)
    {
        sum[i] = max(sum[i - 2] + nums[i], sum[i - 1]);
    }
    return sum[numsSize - 1];
}

总结：动态规划就是通过调用函数关系，通过一次遍历求得每项的最优解，直到最后
所求得最优解。

5.24：Fizz Bizz

题目要求：写一个程序，输出从 1 到 n 数字的字符串表示。
1. 如果 n 是3的倍数，输出“Fizz”；
2. 如果 n 是5的倍数，输出“Buzz”；
3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。
示例：
n = 15,

返回:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]

代码：/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char ** fizzBuzz(int n, int* returnSize){
    int i;
    char t;
    char s1[10];
    char **s = (char **)malloc(sizeof(char *) * n);
    * returnSize = n;
    for(i = 0; i < n; i++)
    {
        if((i + 1) % 15 == 0)
        {
            strcpy(s1, "FizzBuzz");
        }
        else if((i + 1) % 5 == 0)
        {
            strcpy(s1, "Buzz");
        }
        else if((i + 1) % 3 == 0)
        {
            strcpy(s1, "Fizz");
        }
        else
        {
            sprintf(s1, "%d", i + 1);
        }
        *(s + i) = malloc(sizeof(s1));
        strcpy(*(s + i), s1);
    }
    return s;
}

总结：今天这个题目学习了 sprintf 函数的用法，是将数据转化为字符串存入数组中。