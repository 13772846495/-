### 6.4：存在重复元素 II

### 题目要求：

给定一个整数数组和一个整数 *k*，判断数组中是否存在两个不同的索引 *i* 和 *j*，使得 **nums [i] = nums [j]**，并且 *i* 和 *j* 的差的 **绝对值** 至多为 *k*。

**示例 1:**

```
输入: nums = [1,2,3,1], k = 3
输出: true
```

**示例 2:**

```
输入: nums = [1,0,1,1], k = 1
输出: true
```

**示例 3:**

```
输入: nums = [1,2,3,1,2,3], k = 2
输出: false
```

### 代码：

```
bool containsNearbyDuplicate(int* nums, int numsSize, int k){
    int hash[1000];
    memset(hash, 0, 1000);
    int i, min = k + 1, b = 0;
    for(i = 0; i < numsSize; i++)
    {
        if(b == 0 && nums[i] == nums[0])
        {
            if(min > i - hash[nums[0]])
            {
                min = i - hash[nums[0]];
            }
            b++;
        }
        else if(hash[nums[i]] != 0)
        {
            if(min > i - hash[nums[i]])
            {
                min = i - hash[nums[i]];
            }
        }  
        hash[nums[i]] = i;    
    }
    if(k < min)
    {
        return false;
    }
    return true;
}
```

### 执行结果：

#### 提交结果

最后执行的输入：**[-1,-1]  1**

哈希表数组 hash[-1] 执行出错

### 总结：

​		今天利用哈希表解决问题的时候考虑欠妥，跟学长学习了调试功能，最后还是在数组方面出现问题，未考虑负数哈希表就直接用数组去存，最后出现数组越界的问题。
